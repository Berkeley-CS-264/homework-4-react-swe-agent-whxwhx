2025-12-14 08:25:03,522 - INFO - Creating container for astropy__astropy-7166...
2025-12-14 08:25:03,559 - INFO - Container for astropy__astropy-7166 created: 8e3297e64cb6aa4808692b623086e02a1d1f3544537d84924d850b74a1078459
2025-12-14 08:25:03,774 - INFO - Container for astropy__astropy-7166 started: 8e3297e64cb6aa4808692b623086e02a1d1f3544537d84924d850b74a1078459
2025-12-14 08:25:03,774 - INFO - Intermediate patch for astropy__astropy-7166 written to logs/run_evaluation/my_evaluation_run/gpt-5-mini/astropy__astropy-7166/patch.diff, now applying to container...
2025-12-14 08:25:03,877 - INFO - >>>>> Applied Patch:
Checking patch astropy/utils/misc.py...
Applied patch astropy/utils/misc.py cleanly.

2025-12-14 08:25:04,270 - INFO - Git diff before:
diff --git a/astropy/utils/misc.py b/astropy/utils/misc.py
index de3fb01d1..77ea1787e 100644
--- a/astropy/utils/misc.py
+++ b/astropy/utils/misc.py
@@ -528,13 +528,95 @@ class InheritDocstrings(type):
                 not key.startswith('_'))
 
         for key, val in dct.items():
-            if (inspect.isfunction(val) and
-                is_public_member(key) and
-                val.__doc__ is None):
+            if not is_public_member(key):
+                continue
+
+            # Handle plain functions, staticmethod, classmethod, and property.
+            # For staticmethod/classmethod, the underlying function is in __func__.
+            # For property, we need to create a new property with the inherited
+            # docstring if missing.
+            target_func = None
+            wrapper_type = None
+
+            if inspect.isfunction(val):
+                target_func = val
+                wrapper_type = None
+            elif isinstance(val, (staticmethod, classmethod)):
+                # staticmethod and classmethod wrap the function in __func__
+                target_func = val.__func__
+                wrapper_type = type(val)
+            elif isinstance(val, property):
+                # property doesn't expose the function via a uniform attribute,
+                # but fget is the getter function whose __doc__ is used as the
+                # property's docstring. If the property's __doc__ is None,
+                # attempt to inherit from the base.
+                if val.__doc__ is not None:
+                    continue
+                # find a docstring from base classes' attribute
                 for base in cls.__mro__[1:]:
-                    super_method = getattr(base, key, None)
-                    if super_method is not None:
-                        val.__doc__ = super_method.__doc__
+                    super_attr = getattr(base, key, None)
+                    if super_attr is None:
+                        continue
+                    # If the base attribute is a property, use its __doc__
+                    super_doc = getattr(super_attr, '__doc__', None)
+                    if super_doc:
+                        # replace the property in the class dict with one that
+                        # has the inherited docstring
+                        dct[key] = property(fget=val.fget, fset=val.fset,
+                                            fdel=val.fdel, doc=super_doc)
+                        break
+                continue
+            else:
+                # Not a function-like object we care about
+                continue
+
+            # If we have an underlying function to inspect and its doc is None,
+            # try to inherit from base classes.
+            if target_func is None or getattr(target_func, '__doc__', None) is not None:
+                continue
+
+            for base in cls.__mro__[1:]:
+                super_method = getattr(base, key, None)
+                if super_method is None:
+                    continue
+
+                # Unwrap descriptors on the base to get at the function/doc.
+                if isinstance(super_method, (staticmethod, classmethod)):
+                    super_func = super_method.__func__
+                elif isinstance(super_method, property):
+                    # property docstring comes from its getter
+                    super_func = getattr(super_method, '__doc__', None)
+                    # if we got a docstring string, use it directly
+                    if isinstance(super_func, str) and super_func:
+                        # Need to set the doc on the wrapped function or recreate
+                        # the descriptor as appropriate.
+                        if wrapper_type is None:
+                            target_func.__doc__ = super_func
+                        else:
+                            dct[key] = wrapper_type(target_func)
+                            # ensure the wrapped function has the doc
+                            target_func.__doc__ = super_func
+                        break
+                    else:
+                        super_func = None
+                else:
+                    # plain function or other descriptor with __doc__
+                    super_func = getattr(super_method, '__doc__', None)
+
+                if super_func:
+                    # If super_func is a function, get its __doc__; otherwise it
+                    # may already be a docstring.
+                    doc = super_func.__doc__ if inspect.isfunction(super_func) else super_func
+                    if doc:
+                        # Apply the docstring to the target. If it was wrapped
+                        # (staticmethod/classmethod), recreate the wrapper so
+                        # the class attribute remains of the same descriptor type.
+                        if wrapper_type is None:
+                            target_func.__doc__ = doc
+                        else:
+                            # recreate the wrapper around the function (which
+                            # now has its doc set)
+                            dct[key] = wrapper_type(target_func)
                         break
 
         super().__init__(name, bases, dct)
2025-12-14 08:25:04,270 - INFO - Eval script for astropy__astropy-7166 written to logs/run_evaluation/my_evaluation_run/gpt-5-mini/astropy__astropy-7166/eval.sh; copying to container...
2025-12-14 08:25:08,263 - INFO - Test runtime: 3.91 seconds
2025-12-14 08:25:08,264 - INFO - Test output for astropy__astropy-7166 written to logs/run_evaluation/my_evaluation_run/gpt-5-mini/astropy__astropy-7166/test_output.txt
2025-12-14 08:25:08,339 - INFO - Git diff after:
diff --git a/astropy/utils/misc.py b/astropy/utils/misc.py
index de3fb01d1..77ea1787e 100644
--- a/astropy/utils/misc.py
+++ b/astropy/utils/misc.py
@@ -528,13 +528,95 @@ class InheritDocstrings(type):
                 not key.startswith('_'))
 
         for key, val in dct.items():
-            if (inspect.isfunction(val) and
-                is_public_member(key) and
-                val.__doc__ is None):
+            if not is_public_member(key):
+                continue
+
+            # Handle plain functions, staticmethod, classmethod, and property.
+            # For staticmethod/classmethod, the underlying function is in __func__.
+            # For property, we need to create a new property with the inherited
+            # docstring if missing.
+            target_func = None
+            wrapper_type = None
+
+            if inspect.isfunction(val):
+                target_func = val
+                wrapper_type = None
+            elif isinstance(val, (staticmethod, classmethod)):
+                # staticmethod and classmethod wrap the function in __func__
+                target_func = val.__func__
+                wrapper_type = type(val)
+            elif isinstance(val, property):
+                # property doesn't expose the function via a uniform attribute,
+                # but fget is the getter function whose __doc__ is used as the
+                # property's docstring. If the property's __doc__ is None,
+                # attempt to inherit from the base.
+                if val.__doc__ is not None:
+                    continue
+                # find a docstring from base classes' attribute
                 for base in cls.__mro__[1:]:
-                    super_method = getattr(base, key, None)
-                    if super_method is not None:
-                        val.__doc__ = super_method.__doc__
+                    super_attr = getattr(base, key, None)
+                    if super_attr is None:
+                        continue
+                    # If the base attribute is a property, use its __doc__
+                    super_doc = getattr(super_attr, '__doc__', None)
+                    if super_doc:
+                        # replace the property in the class dict with one that
+                        # has the inherited docstring
+                        dct[key] = property(fget=val.fget, fset=val.fset,
+                                            fdel=val.fdel, doc=super_doc)
+                        break
+                continue
+            else:
+                # Not a function-like object we care about
+                continue
+
+            # If we have an underlying function to inspect and its doc is None,
+            # try to inherit from base classes.
+            if target_func is None or getattr(target_func, '__doc__', None) is not None:
+                continue
+
+            for base in cls.__mro__[1:]:
+                super_method = getattr(base, key, None)
+                if super_method is None:
+                    continue
+
+                # Unwrap descriptors on the base to get at the function/doc.
+                if isinstance(super_method, (staticmethod, classmethod)):
+                    super_func = super_method.__func__
+                elif isinstance(super_method, property):
+                    # property docstring comes from its getter
+                    super_func = getattr(super_method, '__doc__', None)
+                    # if we got a docstring string, use it directly
+                    if isinstance(super_func, str) and super_func:
+                        # Need to set the doc on the wrapped function or recreate
+                        # the descriptor as appropriate.
+                        if wrapper_type is None:
+                            target_func.__doc__ = super_func
+                        else:
+                            dct[key] = wrapper_type(target_func)
+                            # ensure the wrapped function has the doc
+                            target_func.__doc__ = super_func
+                        break
+                    else:
+                        super_func = None
+                else:
+                    # plain function or other descriptor with __doc__
+                    super_func = getattr(super_method, '__doc__', None)
+
+                if super_func:
+                    # If super_func is a function, get its __doc__; otherwise it
+                    # may already be a docstring.
+                    doc = super_func.__doc__ if inspect.isfunction(super_func) else super_func
+                    if doc:
+                        # Apply the docstring to the target. If it was wrapped
+                        # (staticmethod/classmethod), recreate the wrapper so
+                        # the class attribute remains of the same descriptor type.
+                        if wrapper_type is None:
+                            target_func.__doc__ = doc
+                        else:
+                            # recreate the wrapper around the function (which
+                            # now has its doc set)
+                            dct[key] = wrapper_type(target_func)
                         break
 
         super().__init__(name, bases, dct)
2025-12-14 08:25:08,339 - INFO - Grading answer for astropy__astropy-7166...
2025-12-14 08:25:08,340 - INFO - report: {'astropy__astropy-7166': {'patch_is_None': False, 'patch_exists': True, 'patch_successfully_applied': True, 'resolved': False, 'tests_status': {'FAIL_TO_PASS': {'success': [], 'failure': ['astropy/utils/tests/test_misc.py::test_inherit_docstrings']}, 'PASS_TO_PASS': {'success': ['astropy/utils/tests/test_misc.py::test_isiterable', 'astropy/utils/tests/test_misc.py::test_signal_number_to_name_no_failure', 'astropy/utils/tests/test_misc.py::test_skip_hidden', 'astropy/utils/tests/test_misc.py::test_JsonCustomEncoder', 'astropy/utils/tests/test_misc.py::test_check_broadcast', 'astropy/utils/tests/test_misc.py::test_dtype_bytes_or_chars'], 'failure': []}, 'FAIL_TO_FAIL': {'success': [], 'failure': []}, 'PASS_TO_FAIL': {'success': [], 'failure': []}}}}
Result for astropy__astropy-7166: resolved: False
2025-12-14 08:25:08,340 - INFO - Attempting to stop container sweb.eval.astropy__astropy-7166.my_evaluation_run...
2025-12-14 08:25:23,612 - INFO - Attempting to remove container sweb.eval.astropy__astropy-7166.my_evaluation_run...
2025-12-14 08:25:23,627 - INFO - Container sweb.eval.astropy__astropy-7166.my_evaluation_run removed.
